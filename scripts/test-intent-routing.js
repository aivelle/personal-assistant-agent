#!/usr/bin/env node

// scripts/test-intent-routing.js
// Intent ÎùºÏö∞ÌåÖ ÏãúÏä§ÌÖúÏùÑ ÌÖåÏä§Ìä∏ÌïòÎäî Ïä§ÌÅ¨Î¶ΩÌä∏

const fs = require('fs');
const path = require('path');

/**
 * ÎùºÏö∞ÌåÖ Í∑úÏπôÏùÑ Î°úÎìúÌï©ÎãàÎã§
 * @returns {Object|null} - ÎùºÏö∞ÌåÖ Í∑úÏπô Í∞ùÏ≤¥ ÎòêÎäî null
 */
function loadRoutingRules() {
  const routingRulesPath = path.join(process.cwd(), 'rules', 'routing-rules.json');
  
  if (!fs.existsSync(routingRulesPath)) {
    console.error('‚ùå Error: routing-rules.json not found');
    console.log('   Run: node scripts/generate-routing-rules.js');
    return null;
  }
  
  try {
    const content = fs.readFileSync(routingRulesPath, 'utf8');
    return JSON.parse(content);
  } catch (error) {
    console.error('‚ùå Error loading routing rules:', error.message);
    return null;
  }
}

/**
 * ÏÇ¨Ïö©Ïûê ÏûÖÎ†•Ïóê ÎåÄÌï¥ intentÎ•º Îß§Ïπ≠Ìï©ÎãàÎã§
 * @param {string} userInput - ÏÇ¨Ïö©Ïûê ÏûÖÎ†•
 * @param {Object} routingRules - ÎùºÏö∞ÌåÖ Í∑úÏπô
 * @returns {Object|null} - Îß§Ïπ≠Îêú intent Ï†ïÎ≥¥ ÎòêÎäî null
 */
function matchIntent(userInput, routingRules) {
  const { rules } = routingRules.routing;
  const matches = [];
  
  // Î™®Îì† Í∑úÏπôÏóê ÎåÄÌï¥ Îß§Ïπ≠ Ï†êÏàò Í≥ÑÏÇ∞
  for (const [intentKey, rule] of Object.entries(rules)) {
    if (!rule.enabled) continue;
    
    let score = 0;
    let matchedTriggers = [];
    
    // Ìä∏Î¶¨Í±∞ ÌÇ§ÏõåÎìú Îß§Ïπ≠
    for (const trigger of rule.triggers) {
      if (userInput.toLowerCase().includes(trigger.toLowerCase())) {
        score += 10;
        matchedTriggers.push(trigger);
      }
    }
    
    // ÏòàÏãú Î¨∏Ïû•Í≥ºÏùò Ïú†ÏÇ¨ÎèÑ Ï≤¥ÌÅ¨ (Í∞ÑÎã®Ìïú ÌÇ§ÏõåÎìú Îß§Ïπ≠)
    for (const example of rule.examples) {
      const exampleWords = example.toLowerCase().split(/\s+/);
      const inputWords = userInput.toLowerCase().split(/\s+/);
      
      let commonWords = 0;
      for (const word of inputWords) {
        if (exampleWords.includes(word) && word.length > 2) {
          commonWords++;
        }
      }
      
      if (commonWords > 0) {
        score += commonWords * 2;
      }
    }
    
    // Ïπ¥ÌÖåÍ≥†Î¶¨Î™ÖÏù¥ Ìè¨Ìï®Îêú Í≤ΩÏö∞ Î≥¥ÎÑàÏä§
    if (userInput.toLowerCase().includes(rule.category.toLowerCase())) {
      score += 5;
    }
    
    if (score > 0) {
      matches.push({
        intent: intentKey,
        rule: rule,
        score: score,
        matchedTriggers: matchedTriggers,
        priority: rule.priority
      });
    }
  }
  
  // Ï†êÏàòÏôÄ Ïö∞ÏÑ†ÏàúÏúÑÎ°ú Ï†ïÎ†¨
  matches.sort((a, b) => {
    if (a.score !== b.score) {
      return b.score - a.score; // Ï†êÏàò ÎÜíÏùÄ Ïàú
    }
    return b.priority - a.priority; // Ïö∞ÏÑ†ÏàúÏúÑ ÎÜíÏùÄ Ïàú
  });
  
  return matches.length > 0 ? matches[0] : null;
}

/**
 * Îã®Ïùº ÌÖåÏä§Ìä∏Î•º Ïã§ÌñâÌï©ÎãàÎã§
 * @param {string} userInput - ÏÇ¨Ïö©Ïûê ÏûÖÎ†•
 * @param {string} expectedIntent - ÏòàÏÉÅÎêòÎäî intent
 * @param {Object} routingRules - ÎùºÏö∞ÌåÖ Í∑úÏπô
 * @returns {Object} - ÌÖåÏä§Ìä∏ Í≤∞Í≥º
 */
function runSingleTest(userInput, expectedIntent, routingRules) {
  const match = matchIntent(userInput, routingRules);
  
  const result = {
    input: userInput,
    expected: expectedIntent,
    actual: match ? match.intent : 'no-match',
    success: match && match.intent === expectedIntent,
    score: match ? match.score : 0,
    matchedTriggers: match ? match.matchedTriggers : [],
    allMatches: []
  };
  
  // ÏÉÅÏúÑ 3Í∞ú Îß§Ïπò Í≤∞Í≥ºÎèÑ Ìè¨Ìï®
  const allMatches = [];
  for (const [intentKey, rule] of Object.entries(routingRules.routing.rules)) {
    if (!rule.enabled) continue;
    
    let score = 0;
    for (const trigger of rule.triggers) {
      if (userInput.toLowerCase().includes(trigger.toLowerCase())) {
        score += 10;
      }
    }
    
    if (score > 0) {
      allMatches.push({ intent: intentKey, score });
    }
  }
  
  result.allMatches = allMatches
    .sort((a, b) => b.score - a.score)
    .slice(0, 3);
  
  return result;
}

/**
 * ÌÖåÏä§Ìä∏ ÏºÄÏù¥Ïä§Îì§ÏùÑ Ï†ïÏùòÌï©ÎãàÎã§
 * @returns {Array} - ÌÖåÏä§Ìä∏ ÏºÄÏù¥Ïä§ Î∞∞Ïó¥
 */
function getTestCases() {
  return [
    // Create Ïπ¥ÌÖåÍ≥†Î¶¨
    {
      input: "Ïù¥Î©îÏùºÏùÑ Ïç®Ï§ò",
      expected: "create.contentDraft"
    },
    {
      input: "ÏÉà ÌîÑÎ°úÏ†ùÌä∏Î•º ÏãúÏûëÌï¥Ïïº Ìï¥",
      expected: "create.taskPlan"
    },
    {
      input: "ÌöåÏùòÎ•º ÏòàÏïΩÌï¥Ï§ò",
      expected: "create.meeting"
    },
    {
      input: "Ìï† ÏùºÏùÑ Ï∂îÍ∞ÄÌï¥Ï§ò",
      expected: "create.task"
    },
    {
      input: "ÎÇ¥Ïùº ÎØ∏ÌåÖ Î¶¨ÎßàÏù∏Îçî ÏÑ§Ï†ïÌï¥Ï§ò",
      expected: "create.reminder"
    },
    
    // Suggest Ïπ¥ÌÖåÍ≥†Î¶¨
    {
      input: "ÏùºÏù¥ Î∞ÄÎ†∏Ïñ¥",
      expected: "suggest.delayAnalysis"
    },
    {
      input: "Îçî Ìö®Ïú®Ï†ÅÏúºÎ°ú ÏùºÌïòÍ≥† Ïã∂Ïñ¥",
      expected: "suggest.productivityTip"
    },
    {
      input: "ÏùºÏ†ïÏùÑ Î∞îÍøîÏ§ò",
      expected: "suggest.rescheduleOption"
    },
    
    // Manage Ïπ¥ÌÖåÍ≥†Î¶¨
    {
      input: "Ïö∞ÏÑ†ÏàúÏúÑÎ•º Ï†ïÌï¥Ï§ò",
      expected: "manage.prioritySort"
    },
    {
      input: "ÏÉÅÌÉúÎ•º ÏóÖÎç∞Ïù¥Ìä∏Ìï¥Ï§ò",
      expected: "manage.statusUpdate"
    },
    
    // Remind Ïπ¥ÌÖåÍ≥†Î¶¨
    {
      input: "Îç∞ÎìúÎùºÏù∏ÏùÑ ÏïåÎ†§Ï§ò",
      expected: "remind.deadlineAlert"
    },
    {
      input: "ÌõÑÏÜç Ï°∞ÏπòÎ•º ÌôïÏù∏Ìï¥Ï§ò",
      expected: "remind.followUp"
    },
    
    // Retrieve Ïπ¥ÌÖåÍ≥†Î¶¨
    {
      input: "Ï∞æÏïÑÏ§ò",
      expected: "retrieve.dataSearch"
    },
    {
      input: "ÏßÄÎÇúÎã¨ ÌöåÏùòÎ°ùÏùÑ Í≤ÄÏÉâÌï¥Ï§ò",
      expected: "retrieve.dataSearch"
    },
    
    // Summarize Ïπ¥ÌÖåÍ≥†Î¶¨
    {
      input: "ÏöîÏïΩÌï¥Ï§ò",
      expected: "summarize.reportSummary"
    },
    {
      input: "Ïù¥ Î≥¥Í≥†ÏÑúÏùò ÌïµÏã¨ ÎÇ¥Ïö©ÏùÑ Ï†ïÎ¶¨Ìï¥Ï§ò",
      expected: "summarize.reportSummary"
    },
    
    // Insight Ïπ¥ÌÖåÍ≥†Î¶¨
    {
      input: "Ìä∏Î†åÎìúÎ•º Î∂ÑÏÑùÌï¥Ï§ò",
      expected: "insight.trendAnalysis"
    },
    
    // Interact Ïπ¥ÌÖåÍ≥†Î¶¨ (fallback)
    {
      input: "ÏïàÎÖïÌïòÏÑ∏Ïöî",
      expected: "interact.chatResponse"
    },
    {
      input: "ÎèÑÏõÄÏù¥ ÌïÑÏöîÌï¥Ïöî",
      expected: "interact.chatResponse"
    }
  ];
}

/**
 * Î™®Îì† ÌÖåÏä§Ìä∏Î•º Ïã§ÌñâÌïòÍ≥† Í≤∞Í≥ºÎ•º Ï∂úÎ†•Ìï©ÎãàÎã§
 * @param {Object} routingRules - ÎùºÏö∞ÌåÖ Í∑úÏπô
 */
function runAllTests(routingRules) {
  const testCases = getTestCases();
  const results = [];
  
  console.log('üß™ Running Intent Routing Tests...\n');
  
  for (const testCase of testCases) {
    const result = runSingleTest(testCase.input, testCase.expected, routingRules);
    results.push(result);
    
    // Í∞úÎ≥Ñ ÌÖåÏä§Ìä∏ Í≤∞Í≥º Ï∂úÎ†•
    const status = result.success ? '‚úÖ' : '‚ùå';
    console.log(`${status} "${result.input}"`);
    console.log(`   Expected: ${result.expected}`);
    console.log(`   Actual: ${result.actual} (score: ${result.score})`);
    
    if (result.matchedTriggers.length > 0) {
      console.log(`   Matched triggers: ${result.matchedTriggers.join(', ')}`);
    }
    
    if (!result.success && result.allMatches.length > 0) {
      console.log(`   Top matches: ${result.allMatches.map(m => `${m.intent}(${m.score})`).join(', ')}`);
    }
    
    console.log('');
  }
  
  // Ï†ÑÏ≤¥ Í≤∞Í≥º ÌÜµÍ≥Ñ
  const totalTests = results.length;
  const passedTests = results.filter(r => r.success).length;
  const failedTests = totalTests - passedTests;
  const successRate = ((passedTests / totalTests) * 100).toFixed(1);
  
  console.log('üìä Test Results Summary:');
  console.log(`   Total tests: ${totalTests}`);
  console.log(`   Passed: ${passedTests}`);
  console.log(`   Failed: ${failedTests}`);
  console.log(`   Success rate: ${successRate}%`);
  
  // Ïã§Ìå®Ìïú ÌÖåÏä§Ìä∏Îì§ ÏÉÅÏÑ∏ Î∂ÑÏÑù
  if (failedTests > 0) {
    console.log('\n‚ùå Failed Tests Analysis:');
    const failedResults = results.filter(r => !r.success);
    
    for (const failed of failedResults) {
      console.log(`   "${failed.input}"`);
      console.log(`     Expected: ${failed.expected}`);
      console.log(`     Got: ${failed.actual}`);
      
      if (failed.actual === 'no-match') {
        console.log('     Issue: No intent matched - consider adding more triggers');
      } else {
        console.log('     Issue: Wrong intent matched - check trigger specificity');
      }
    }
  }
  
  return {
    totalTests,
    passedTests,
    failedTests,
    successRate: parseFloat(successRate),
    results
  };
}

/**
 * ÎåÄÌôîÌòï ÌÖåÏä§Ìä∏ Î™®ÎìúÎ•º Ïã§ÌñâÌï©ÎãàÎã§
 * @param {Object} routingRules - ÎùºÏö∞ÌåÖ Í∑úÏπô
 */
function runInteractiveMode(routingRules) {
  console.log('üéØ Interactive Intent Testing Mode');
  console.log('Enter user inputs to test intent matching (type "exit" to quit):\n');
  
  const readline = require('readline');
  const rl = readline.createInterface({
    input: process.stdin,
    output: process.stdout
  });
  
  const askInput = () => {
    rl.question('üë§ User input: ', (input) => {
      if (input.toLowerCase() === 'exit') {
        console.log('üëã Goodbye!');
        rl.close();
        return;
      }
      
      if (input.trim() === '') {
        askInput();
        return;
      }
      
      const match = matchIntent(input, routingRules);
      
      if (match) {
        console.log(`üéØ Matched Intent: ${match.intent}`);
        console.log(`   Category: ${match.rule.category}`);
        console.log(`   Title: ${match.rule.title}`);
        console.log(`   Score: ${match.score}`);
        console.log(`   Priority: ${match.priority}`);
        
        if (match.matchedTriggers.length > 0) {
          console.log(`   Triggers: ${match.matchedTriggers.join(', ')}`);
        }
        
        console.log(`   Scenario: ${match.rule.paths.scenario}`);
        console.log(`   Code: ${match.rule.paths.code}`);
      } else {
        console.log('‚ùå No intent matched');
        console.log('   This would fall back to: interact.chatResponse');
      }
      
      console.log('');
      askInput();
    });
  };
  
  askInput();
}

/**
 * Î©îÏù∏ Ïã§Ìñâ Ìï®Ïàò
 */
function main() {
  const args = process.argv.slice(2);
  const isInteractive = args.includes('--interactive') || args.includes('-i');
  
  console.log('üöÄ Intent Routing Test Suite\n');
  
  // ÎùºÏö∞ÌåÖ Í∑úÏπô Î°úÎìú
  const routingRules = loadRoutingRules();
  if (!routingRules) {
    process.exit(1);
  }
  
  console.log(`üìã Loaded ${Object.keys(routingRules.routing.rules).length} routing rules`);
  console.log(`üéØ Fallback intent: ${routingRules.routing.fallback_intent}\n`);
  
  if (isInteractive) {
    runInteractiveMode(routingRules);
  } else {
    const testResults = runAllTests(routingRules);
    
    // ÏÑ±Í≥µÎ•†Ïù¥ ÎÇÆÏúºÎ©¥ Ï¢ÖÎ£å ÏΩîÎìú 1Î°ú Ï¢ÖÎ£å
    if (testResults.successRate < 80) {
      console.log('\n‚ö†Ô∏è  Success rate is below 80%. Consider improving triggers or test cases.');
      process.exit(1);
    } else {
      console.log('\nüéâ All tests passed successfully!');
    }
  }
}

// Ïä§ÌÅ¨Î¶ΩÌä∏Í∞Ä ÏßÅÏ†ë Ïã§ÌñâÎêú Í≤ΩÏö∞ÏóêÎßå main Ìï®Ïàò Ìò∏Ï∂ú
if (require.main === module) {
  main();
}

module.exports = {
  loadRoutingRules,
  matchIntent,
  runSingleTest,
  runAllTests,
  main
}; 